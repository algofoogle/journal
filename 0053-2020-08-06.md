# 6 Aug 2020

## Yet more Verilator

I made [`t01d`](https://github.com/algofoogle/sandpit/tree/master/fpga/verilator/test01/t01d):
*   Uses a [`Makefile`](https://github.com/algofoogle/sandpit/blob/master/fpga/verilator/test01/t01d/Makefile) to build/run the thing now. Just a simple example so far. `make clean` will delete any existing `obj_dir`. `make` is the same as `make all` which does `clean`, then builds the project. `make run` will just do the general (initial 0) run, building if needed. `make run1` and `make run2` will run, respectively, with: (1) all unassigned bits set; (2) unassigned bits randomised.
*   `.gitignore` excludes `obj_dir` now, since it is platform-specific, and all of its contents (for now) can just be rebuilt by Verilator.
*   Actual project is a sawtooth counter (i.e. given a clock, it counts up and then down again). It supports a `SIZE` parameter (defaults to 8-bit output), but I'm not yet sure how to override this in Verilator.
*   Test bench inspects the high bit of `saw_count__DOT__counter` to look inside the module and see whether it's currently counting up or down.

This example:
*   Shows the state of all signals as it runs.
*   Runs an initial 5 clock cycles from cold start (which might include unassigned/random signal states).
*   Does a synchronous reset.
*   Runs for 600 clock cycles.

Run `make` initially, which will delete `obj_dir` and then build it again. Then we can do:

```
$ make run | head -15
Before first eval()...
[00000000] clk=0 reset=0 q=0 (counter)=00000000 (up)
After first eval()...
[00000000] clk=0 reset=0 q=0 (counter)=00000000 (up)
Cold start...
[00000001] clk=0 reset=0 q=1 (counter)=00000001 (up)
[00000002] clk=0 reset=0 q=2 (counter)=00000002 (up)
[00000003] clk=0 reset=0 q=3 (counter)=00000003 (up)
[00000004] clk=0 reset=0 q=4 (counter)=00000004 (up)
[00000005] clk=0 reset=0 q=5 (counter)=00000005 (up)
Synchronous reset...
[00000006] clk=0 reset=1 q=0 (counter)=00000000 (up)
Main loop...
[00000007] clk=0 reset=0 q=1 (counter)=00000001 (up)
[00000008] clk=0 reset=0 q=2 (counter)=00000002 (up)
```

This starts all unassigned signals as cleared.

Likewise, start with all unassigned signals *set*:

```
$ make run1 | head -15
Before first eval()...
[00000000] clk=1 reset=1 q=255 (counter)=000001FF (down)
After first eval()...
[00000000] clk=1 reset=1 q=0 (counter)=000001FF (down)
Cold start...
[00000001] clk=0 reset=1 q=0 (counter)=00000000 (up)
[00000002] clk=0 reset=1 q=0 (counter)=00000000 (up)
[00000003] clk=0 reset=1 q=0 (counter)=00000000 (up)
[00000004] clk=0 reset=1 q=0 (counter)=00000000 (up)
[00000005] clk=0 reset=1 q=0 (counter)=00000000 (up)
Synchronous reset...
[00000006] clk=0 reset=1 q=0 (counter)=00000000 (up)
Main loop...
[00000007] clk=0 reset=0 q=1 (counter)=00000001 (up)
[00000008] clk=0 reset=0 q=2 (counter)=00000002 (up)
```

Then this is how it looks with random values. Note how `q` needs the first `eval()` in order to "settle", even though it is an `assign`ed (rather than `reg`istered) value:

```
$ make run2 SEED=993 | head -15
Before first eval()...
[00000000] clk=0 reset=0 q=225 (counter)=000001F0 (down)
After first eval()...
[00000000] clk=0 reset=0 q=15 (counter)=000001F0 (down)
Cold start...
[00000001] clk=0 reset=0 q=14 (counter)=000001F1 (down)
[00000002] clk=0 reset=0 q=13 (counter)=000001F2 (down)
[00000003] clk=0 reset=0 q=12 (counter)=000001F3 (down)
[00000004] clk=0 reset=0 q=11 (counter)=000001F4 (down)
[00000005] clk=0 reset=0 q=10 (counter)=000001F5 (down)
Synchronous reset...
[00000006] clk=0 reset=1 q=0 (counter)=00000000 (up)
Main loop...
[00000007] clk=0 reset=0 q=1 (counter)=00000001 (up)
[00000008] clk=0 reset=0 q=2 (counter)=00000002 (up)
```



## Other things to review

*   How to override Verilog `parameter`s in Verilator?
*   Need to try out [GTKWave](http://gtkwave.sourceforge.net/) for Windows and macOS. At the time of writing, win64 binary is only up to [3.3.100](https://sourceforge.net/projects/gtkwave/files/gtkwave-3.3.100-bin-win64/), and macOS only up to [3.3.103](https://sourceforge.net/projects/gtkwave/files/gtkwave-3.3.103-osx-app/), and can also be installed via `brew install gtkwave`? Check out the list of all releases [here](https://sourceforge.net/projects/gtkwave/files/).
*   [VCD file format](https://en.wikipedia.org/wiki/Value_change_dump) seems pretty straightforward.
*   [FST (Fast Signal Trace)](http://gtkwave.sourceforge.net/gtkwave.pdf#page=135&zoom=100,132,72) is an alternative to VCD, [used by GTKWave](https://www.veripool.org/projects/verilator/wiki/Manual-verilator#How-do-I-generate-FST-waveforms-traces-in-C). Maybe it has more features? It definitely has compression.
*   [CVC](http://www.tachyon-da.com/what-is-cvc/) is an alternative to Verilator and Icarus?
*   Comments on [Accessing Signals in Verilator Models](https://www.embecosm.com/appnotes/ean6/html/ch06s02.html) (see also; its subheadings 6.2.x).
*   Learn Makefiles and produce one for use in Verilator, XISE projects, etc. [This looks like a great tutorial](https://makefiletutorial.com/) but I recall a similar site that might have been even better.

