# 5 Aug 2020

## A little more Verilator

Created [`t01c`](https://github.com/algofoogle/sandpit/tree/master/fpga/verilator/test01/t01c). It's mostly the same as `t01b` but has an internal `overflow` register. This gets set when it counts from 255 to 0, but otherwise is unused. We get a warning to that effect:

```
$ verilator -Wall --cc counter.v --exe --build sim_main.cpp
%Warning-UNUSED: counter.v:7:5: Signal is not used: 'overflow'
                              : ... In instance counter
    7 | reg overflow;
      |     ^~~~~~~~
                 ... Use "/* verilator lint_off UNUSED */" and lint_on around source to disable this message.
%Error: Exiting due to 1 warning(s)
```

With `-Wall` specified, it stops the build right there.

In conflict with what [this](https://zipcpu.com/blog/2017/06/21/looking-at-verilator.html) said in 2017, internal module signals are not exactly accessed using the `v__DOT__...` pattern. Specifically, this is what I found:
*   Internal signals are not exposed by default, or so it seems. When I ran `verilator` using the command-line above, the resulting source code files in `obj_dir` have no mention of `overflow` in them. Either `overflow` was "optimised out" (because it has no effect and is not an output) or Verilator is choosing not to expose them in any accessible way.
*   You can use the [`--public` switch](https://www.veripool.org/wiki/verilator/Manual-verilator#public) with Verilator, and this then does expose a member variable with the name `counter__DOT__overflow`. Note that the doco for `--public` says that it "is only for historical debug use". It warns about effects it might have on simulation of generated clocks.
*   It might be better to use [`--public-flat-rw`](https://www.veripool.org/wiki/verilator/Manual-verilator#public-flat-rw). I'm not really sure what the difference is between the two.

Anyway, I did this:

```bash
verilator --public-flat-rw  --cc counter.v --exe --build sim_main.cpp
```

...and was then able to access `m_core->counter__DOT__overflow` in the code. Thus, I could run:

```
$ obj_dir/Vcounter +verilator+rand+reset+0

    Cold start...
    [00000000] counter.q=0 counter.(overflow)=0
    Counted   0
    [00000001] counter.q=1 counter.(overflow)=0
    [00000002] counter.q=2 counter.(overflow)=0
    [00000003] counter.q=3 counter.(overflow)=0
    [00000004] counter.q=4 counter.(overflow)=0
    [00000005] counter.q=5 counter.(overflow)=0
    Synchronous reset...
    [00000006] counter.q=0 counter.(overflow)=0
    Main loop...
    Counted   0
    [00000007] counter.q=1 counter.(overflow)=0
    [00000008] counter.q=2 counter.(overflow)=0
    [00000009] counter.q=3 counter.(overflow)=0
    [00000010] counter.q=4 counter.(overflow)=0
    [00000011] counter.q=5 counter.(overflow)=0
    [00000012] counter.q=6 counter.(overflow)=0
    [00000013] counter.q=7 counter.(overflow)=0
    [00000014] counter.q=8 counter.(overflow)=0
...
    [00000103] counter.q=97 counter.(overflow)=0
    [00000104] counter.q=98 counter.(overflow)=0
    [00000105] counter.q=99 counter.(overflow)=0
    [00000106] counter.q=100 counter.(overflow)=0
    Counted 100
    [00000107] counter.q=101 counter.(overflow)=0
    [00000108] counter.q=102 counter.(overflow)=0
...
    [00000115] counter.q=109 counter.(overflow)=0
    [00000116] counter.q=110 counter.(overflow)=0
    - counter.v:19: Verilog $finish
    [00000117] counter.q=111 counter.(overflow)=0
```

...and:

```
$ obj_dir/Vcounter +verilator+rand+reset+1
    Cold start...
    [00000000] counter.q=255 counter.(overflow)=1
    Counted 255
    [00000001] counter.q=0 counter.(overflow)=0
    Counted   0
    [00000002] counter.q=0 counter.(overflow)=0
    Counted   0
    [00000003] counter.q=0 counter.(overflow)=0
    Counted   0
    [00000004] counter.q=0 counter.(overflow)=0
    Counted   0
    [00000005] counter.q=0 counter.(overflow)=0
    Synchronous reset...
    Counted   0
    [00000006] counter.q=0 counter.(overflow)=0
    Main loop...
    Counted   0
    [00000007] counter.q=1 counter.(overflow)=0
    [00000008] counter.q=2 counter.(overflow)=0
    [00000009] counter.q=3 counter.(overflow)=0
...
(the rest is the same as above)
```

Note above that we see `reset` held on, for those initial ticks.

**Don't forget** that the initial `reset()` call does a clock tick. In the output above we see the result of `q <= 0` after `reset` has been asserted, and then we see this:

```
    [00000007] counter.q=1 counter.(overflow)=0
```

...which is the result *after* `tick()` has completed.


## Other things to review

*   Read more about [VPI](https://www.veripool.org/wiki/verilator/Manual-verilator#VERIFICATION-PROCEDURAL-INTERFACE-VPI)
*   Read more about generated clocks, starting maybe with [this bit](https://www.veripool.org/wiki/verilator/Manual-verilator#Generated-Clocks).
