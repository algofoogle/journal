# 28 Oct 2023

| Previous journal: | Next journal: |
|-|-|
| [**0167**-2023-10-27.md](./0167-2023-10-27.md) | *Next journal TBA* |

# Again more prep for chipIgnite

## Done

*   Instantiated my design (top_ew_algofoogle) using SNIPPET1_NoShare.
*   Modified design to buffer texture data from `io[2:0]` instead of `io[3:1]` because io3 might not be available in our assigned IO pads.
*   Because of texture buffer change, I modified texy.py to write out its ROM image in XBGRXBGR format instead of BGRXBGRX.
*   Wrote updated texture ROM to test with updated design on FPGA
*   Got it working with initial frame rendering test: Had to fix some issues, but seems fine now, and it can generate an output full-frame VGA preview from cocotb too.
*   Removed other tests.


## Plan

NOTE: Remember that my own [`copy_caravel_stuff.sh`](https://github.com/algofoogle/solo_squash/blob/main/caravel_stuff/copy_caravel_stuff.sh) might help us. Should we do the same [`caravel_stuff/`](https://github.com/algofoogle/solo_squash/blob/main/caravel_stuff/) structure for raybox-zero? Likewise there's the repo that I actually made using this method (I think): [solo-squash-caravel](https://github.com/algofoogle/solo-squash-caravel)

Borrow *just a little* from my [solo-squash cocotb tests](https://github.com/algofoogle/solo_squash/blob/main/caravel_stuff/test_solo_squash_caravel.py) and also robojan's cocotb tests for his TT04 'Breakout' clone.

Z2A MPW9 update refers to OpenLane improved checks inc. for OEB and CVC: "precheck now checks for oeb issues, includes cvc, required lvs configuration"

*   Implement basic cocotb test: Wire up Texture SPI ROM (and fix QE bit); Firmware to set up GPIOs/LA and issue/release reset.
*   Harden GDS macro and user project area
*   Commit the repo with new remote
*   Work out if [use of IRQs (`user_irq`)](https://github.com/efabless/caravel_user_project/blob/872a4fc82fbd96448232186858c0ed4bffc991b4/verilog/rtl/user_project_wrapper.v#L77-L78) is safe -- are they masked by default? We don't want them firing all over the place and interrupting our firmware, or anyone else's.
*   Option for un/registered RGB outputs
*   Prep SNIPPET2 and SNIPPET3
*   Update EWSPEC as needed
*   Put in other general raybox-zero features
*   Try newer OpenLane 1.x and updated CUP

## Other test outputs suggested for gpout muxes or alts

*   VGA hmax/vmax
*   VGA visible

# Process

Let's go!

## Prep clean CUP and call it raybox-zero-caravel

### Get clean CUP if necessary

*   First up, I'm using caravel_user_project in MPW8 VM. It's a clean copy as distributed with the VM.
*   This is being done on my laptop.
*   Extract my backup copy *if necessary*:
    *   Delete or archive old `caravel_user_project`
    *   ```bash
        cd ~/asic_tools
        tar xjf CUP-mpw-8c-Z2A-original-2022-12-29.tar.bz2
        mv CUP-mpw-8c-Z2A-original-2022-12-29 caravel_user_project
        ```
*   Symlink for CUP: `ln -s ~/asic_tools/caravel_user_project ~/CUP`
*   `git log` shows:
    ```
    commit bae93e078005210307b7530e53d4a0c060ed5c54 (HEAD, tag: mpw-8c)
    Author: Jeff DiCorpo <42048757+jeffdi@users.noreply.github.com>
    Date:   Fri Nov 25 11:53:53 2022 -0800

        tag = mpw-8c
    ```
*   `git status` shows the only changes are added directories:
    ```
    caravel/
    deps/
    mgmt_core_wrapper/
    venv/
    ```

### Start the new raybox-zero-caravel CUP repo

This will use the mpw-8c clean CUP repo as the basis for our new raybox-zero-caravel repo, specifically on the **`ew` branch** as the default.

1.  Create new GitHub repo called [raybox-zero-caravel](https://github.com/algofoogle/raybox-zero-caravel)
2.  Go into working CUP and prepare its remote hook-up to the new repo, but **making an `ew` branch *as the default***:
    ```bash
    cd ~/CUP
    git checkout -b ew
    git remote add anton git@github.com:algofoogle/raybox-zero-caravel.git
    git push -u anton ew
    ```
3.  Refresh the repo in GitHub and it should show that `ew` is now the default branch.
4.  `git branch -a` should include remotes/**anton**/ew
5.  `git branch -vv` should show that our `ew` branch is using the `anton/ew` remote:
    ```
    $ git branch -vv
    * ew   bae93e0 [anton/ew] tag = mpw-8c
      main 4fabf74 [origin/main] Merge pull request #223 from efabless/timing-scripts-report-summary-updates
    ```

## Instantiate my design (top_ew_algofoogle) - SNIPPET1_NoShare version

1.  Make raybox-zero a [submodule](https://github.com/algofoogle/raybox-zero-caravel/commit/19ebe30f443ae5118a33a24d74968d120b5e3a35#diff-fe7afb5c9c916e521401d3fcfb4277d5071798c3baf83baf11d6071742823584) in `verilog/rtl`:
    ```bash
    cd ~/CUP
    git submodule add -b ew git@github.com:algofoogle/raybox-zero verilog/rtl/raybox-zero
    ```
2.  [Replace](https://github.com/algofoogle/raybox-zero-caravel/commit/19ebe30f443ae5118a33a24d74968d120b5e3a35#diff-ae099be4441f3203d570d7b5fd5bb989320ca03332623948d91f33a7dec57a53)
    `verilog/includes/includes.rtl.caravel_user_project` with the following:
    ```
    # Caravel user project includes
    -v $(USER_PROJECT_VERILOG)/rtl/user_project_wrapper.v
    -v $(USER_PROJECT_VERILOG)/rtl/raybox-zero/src/rtl/top_ew_algofoogle.v
    -v $(USER_PROJECT_VERILOG)/rtl/raybox-zero/src/rtl/debug_overlay.v
    -v $(USER_PROJECT_VERILOG)/rtl/raybox-zero/src/rtl/fixed_point_params.v
    -v $(USER_PROJECT_VERILOG)/rtl/raybox-zero/src/rtl/helpers.v
    -v $(USER_PROJECT_VERILOG)/rtl/raybox-zero/src/rtl/lzc.v
    -v $(USER_PROJECT_VERILOG)/rtl/raybox-zero/src/rtl/map_overlay.v
    -v $(USER_PROJECT_VERILOG)/rtl/raybox-zero/src/rtl/map_rom.v
    -v $(USER_PROJECT_VERILOG)/rtl/raybox-zero/src/rtl/pov.v
    -v $(USER_PROJECT_VERILOG)/rtl/raybox-zero/src/rtl/rbzero.v
    -v $(USER_PROJECT_VERILOG)/rtl/raybox-zero/src/rtl/reciprocal.v
    -v $(USER_PROJECT_VERILOG)/rtl/raybox-zero/src/rtl/row_render.v
    -v $(USER_PROJECT_VERILOG)/rtl/raybox-zero/src/rtl/spi_registers.v
    -v $(USER_PROJECT_VERILOG)/rtl/raybox-zero/src/rtl/vga_mux.v
    -v $(USER_PROJECT_VERILOG)/rtl/raybox-zero/src/rtl/vga_sync.v
    -v $(USER_PROJECT_VERILOG)/rtl/raybox-zero/src/rtl/wall_tracer.v
    ```
3.  Edit `verilog/rtl/user_project_wrapper.v` to [replace](https://github.com/algofoogle/raybox-zero-caravel/commit/19ebe30f443ae5118a33a24d74968d120b5e3a35#diff-83ac0ef05662841c8ec520d2b084e2d44e493e7d323ba22cb43b27d24d820397) the `user_proj_example` instance with [SNIPPET1_NoShare](https://github.com/algofoogle/raybox-zero/blob/ew/src/rtl/ew_caravel_snippets/SNIPPET1_NoShare.v).
4.  Remove old stuff we don't need from the example project:
    ```bash
    git rm verilog/rtl/user_proj_example.v
    git rm -r verilog/dv/io_ports
    git rm -r verilog/dv/la_test1
    git rm -r verilog/dv/la_test2
    git rm -r verilog/dv/mprj_stimulus
    git rm -r verilog/dv/wb_port
    ```
5.  Edit README a bit.
6.  [Commit](https://github.com/algofoogle/raybox-zero-caravel/commit/19ebe30f443ae5118a33a24d74968d120b5e3a35) these changes:
    ```bash
    git commit -am "Starting to instantiate raybox-zero project via submodule"
    git push
    ```

## Implement basic cocotb tests

1.  ```bash
    cd ~/CUP/verilog/dv
    mkdir rbz_basic
    ```
2.  Create all files to be based on the 'rbz_basic' (test) name, so that default `make ...` actions will find them, i.e. note that `coco_test` depends on `rbz_basic.hex`. Make sure this is also the `rbz_basic.vcd` file we'll write in the TB.
3.  Note that I had to make some changes to the standard `Makefile` as used by the CUP examples, because I rely on the following;
    *   A SystemVerilog feature for doing conversion/casting of constants (to help with real-to-fixed-point number conversion).
    *   Additional `W25Q128JVxIM` module used only in testing, to simulate the external texture SPI flash ROM.
    *   `` `include `` references to include files, which we need to tell iverilog to find in the same path as our main RTL source files.
4.  Add in `texture_rom/` subdir and files.
5.  Run the test to generate `rbz_basic.vcd`: `make coco_test` -- It runs a bit over 1.5M clocks so it takes a while (about 16 minutes on my laptop).
6.  View the resulting VCD with GTKWave, using a 'Save File' for formatting: `gtkwave rbz_basic.vcd rbz_basic.gtkw` -- NOTE: I've already made that .gtkw and put it into the repo.

View showing texture SPI flash ROM **not** configured to support QSPI (`QE`) mode:

![GTKWave showing trace without QSPI working](i/0168-data-holes.png)

Note how there are red 'holes' in the outputs, which I think match the region of each line which *would* be textured wall. I think this is working as expected.

Close-up of the start of the frame:

![Start of frame close-up](i/0168-holes-closeup.png)

Hmm, interesting:
*   First line appears to be all floor/ceiling. Maybe to be expected if no size calculated yet (0?)
*   First texture SPI read includes an unknown (`x`) address bit. Probably makes sense: We HAVE observed that there appears to be a 1-line lag in updating the texture address.
*   Surprisingly, next 4 lines look like they are showing a tall wall region. Is this a very-edge fragment of a near wall? I don't see this in `make csr`. I wonder if subsequent frames show they same thing.

If we zoom right in to the very end, we can see where the next frame starts (that 1 extra clock inserted in the test):

![Start of next frame](i/0168-start-next-frame.png)

I modified `texture_rom/sreg.hex` to set the 9th zero (from the left) to 1. This represents the QE bit, so this is the same effect as having QE pre-programmed to be on (as is the case with the chips I'm using, and as is the assumption of the raybox-zero SPI implementation). This made the unknown states disappear in the gpouts.

Through testing I uncovered that I didn't have any blue texture data coming in, because io3 is unused but the design was using io[3:1] as the source for its buffers. As a result I changed it to io[2:0] and made sure the blue data was in io0 instead of io3 (so I had to update the texture ROM, and for that I had to update texy.py).

I added a feature to the `rbz_basic:test_all` test to write the gpout data it receives to a PPM file, so we can actually visualise what the simulation is spitting out:

![Test image generated by cocotb](./i/0168-cocotb-test-image.png)

In this case, I set it up to render 4 frames, rather than just the usual 1 that the test does. NOTE: The image is rotated above.

NOTE: It's not obvious from looking at the images above, but the first frame (LHS) is shifted a lot more than the others. I think this is something to do with the start-up state of the FSM. From what I can tell, the vectors are behaving normally between frames.

**NOTE: Remember to [commit everything](https://github.com/algofoogle/raybox-zero-caravel/commit/69ef5d025afafa5ff8f265620aff3c63e6f1f93b) if it works OK!**


# Writing texture ROM image to SPI flash ROM chip

1.  Plug Bus Pirate into laptop while MPW8 VM is running -- pass-thru should pick it up. Check with `sudo dmesg -T`
2.  Go to where the ROM image file is found.
3.  Adapt and run the following for your chip type and ROM image filename (.bin):
```bash
SPICHIP=AT25SF081
SPIPORT=buspirate_spi:dev=/dev/ttyUSB0,spispeed=2M,serialspeed=250000
time flashrom -c $SPICHIP -p $SPIPORT -w goodwolfwalls-2xbgr.bin
# It took about 02:43
```


# Next steps

*   Test with `make csr`! It's not definitive but Without it we're even more at the mercy of the difference between Quartus and Yosys!
*   Fix cocotb deprecation:
    ```
    /home/zerotoasic/asic_tools/caravel_user_project/verilog/dv/rbz_basic/test_rbz_basic.py:12: DeprecationWarning: cocotb.fork has been deprecated in favor of cocotb.start_soon and cocotb.start.
    In most cases you can simply substitute cocotb.fork with cocotb.start_soon.
    ```
*   [Coroutines are used in cocotb for running stuff in parallel](https://docs.cocotb.org/en/stable/writing_testbenches.html#concurrent-and-sequential-execution), e.g. monitoring for an event alongside another test.
*   Find out: In cocotb, when working with a bidirectional wire, do we need to assign `Z` in cocotb in order to be able to read it? i.e. will a preexisting 1 or 0 value in cocotb override what the design is trying to drive?
*   Feed o_reset back to a LA.
*   Implement a test to make sure essential constants (e.g. for reciprocal and pov) are being defined properly during synth
*   Check the GHAs for raybox-zero-caravel: Disable, fix, or replace with our own
*   Adapt my TT05 design to support the VGA PMOD spec, and maybe the same for SPI ROM: https://tinytapeout.com/specs/pinouts/

# Analog

*   Probably need extra power nets? In UPW as well as config.tcl

# Notes

*   These are the textures I selected from `assets/allwolfwalls.png`:
    ```ps
    py texy.py ..\assets\allwolfwalls.png walls.bin `
        -m 1.4 -b 20 -f 2xbgr -p 1048576 `
        -s 78,79,66,67,46,47,50,51,0,1,2,3,52,53,14,15,16,17,8,9,12,13,32,33,38,39,22,23,44,45,86,87,88,89,98,99,100,101
    ```
*   LEF files can be viewed in KLayout. They basically just seem to show main area, obstructions (keepouts) per layer, pins per layer, and labels:

    ![LEF example for a previous raybox-zero harden](i/0168-lef-example.png)

    ...and a close-up:

    ![LEF close-up](i/0168-lef-closeup.png)
*   DEFs show quite a bit more detail, but still not the whole thing. Not sure what they're for...

    ![DEF example](i/0168-def-example.png)

    ...and close-up:

    ![DEF close-up](i/0168-def-closeup.png)

    Notice that unconnected nets haven't retained their name, and have gone generic, in the top-right corner...?

    Close-up on a more detailed area:

    ![DEF close-up 2](i/0168-def-closeup2.png)
*   Normally I think a DEF would show all the cells, doing so by referencing them from the 'tech' file. These warnings were spat out by KLayout in the console:
    ```
    ...
    Warning: Macro not found in LEF file: sky130_fd_sc_hd__buf_2 (line=60211, cell=, file=top_ew_algofoogle.def)
    Warning: Macro not found in LEF file: sky130_fd_sc_hd__dlymetal6s2s_1 (line=60212, cell=, file=top_ew_algofoogle.def)
    Warning: Macro not found in LEF file: sky130_fd_sc_hd__buf_2 (line=60213, cell=, file=top_ew_algofoogle.def)
    Warning: Macro not found in LEF file: sky130_fd_sc_hd__clkbuf_4 (line=60214, cell=, file=top_ew_algofoogle.def)
    Warning: Macro not found in LEF file: sky130_fd_sc_hd__buf_2 (line=60215, cell=, file=top_ew_algofoogle.def)
    Warning: Macro not found in LEF file: sky130_fd_sc_hd__dlymetal6s2s_1 (line=60216, cell=, file=top_ew_algofoogle.def)
    Warning: Macro not found in LEF file: sky130_fd_sc_hd__clkbuf_2 (line=60217, cell=, file=top_ew_algofoogle.def)
    Warning: Macro not found in LEF file: sky130_fd_sc_hd__clkbuf_2 (line=60218, cell=, file=top_ew_algofoogle.def)
    Warning: Macro not found in LEF file: sky130_fd_sc_hd__dlymetal6s2s_1 (line=60219, cell=, file=top_ew_algofoogle.def)
    Warning: Macro not found in LEF file: sky130_fd_sc_hd__buf_2 (line=60220, cell=, file=top_ew_algofoogle.def)
    ...
    ```
*   Thus, I think a GDS is the raw polygons of each layer, a DEF is the design as a hierarchical arrangement and connection of cells, and the LEF is a high-level structure used for placement and top-level routing.
*   [Caravel Management SoC - Litex](https://caravel-mgmt-soc-litex.readthedocs.io/en/latest/)
*   Learn more about [Wishbone](https://course.zerotoasiccourse.com/mod/lesson/view.php?id=367&pageid=590)
*   Review udpated MPW9 Z2A course material
