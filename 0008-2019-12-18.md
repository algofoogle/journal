# 18 Dec 2019

## Issue with OctoPrint talking via USB to Geeetech A10

I reported yesterday that I was sometimes finding that manual control commands sent from OctoPrint would appear to stall the 3D printer, or at least stall comms with it.

So far, besides restarting things, I've found one workaround: In the OctoPrint UI, there's the "Terminal" tab. Under "Advanced options" there is a button, "Fake Acknowledgement". Clicking this seemed to bring everything back to life.

From what I can tell, OctoPrint gets stuck in a state waiting for acknowledgement of a previous command, and won't send anything else until it receives that acknowledgement. Meanwhile, the printer has already sent the acknowledgement, but it maybe got missed. Faking it means OctoPrint will assume it was received and assume it is safe to continue sending commands.

In the Terminal log, I noticed this, which might be the cause:

```
...
Recv: echo:PID settings:
Recv: echo:  M301 P25.22 I2.68 D59.39
Recv: echo:  M304 P182.46 I35.92 D231.70
Recv:  hardware version:3.90echo:Fixed parameter (6 bytes; crc 45721)
Recv: ok
Changing monitoring state from "Connecting" to "Operational"
Send: N0 M110 N0*125
Recv: echo:S_�ok
Communication timeout while idle, trying to trigger response from printer. Configure long running commands or increase communication timeout if that happens regularly on specific commands or long moves.
Send: N1 M115*39
Recv: FIRMWARE_NAME:Marlin 1.1.8 (Github) SOURCE_CODE_URL:https://github.com/MarlinFirmware/Marlin PROTOCOL_VERSION:1.0 MACHINE_TYPE:A10 EXTRUDER_COUNT:1 UUID:cede2a2f-41a2-4748-9b12-c55c62f367ff
...
```

Note in particular this bit:

```
Recv: echo:S_�ok
```

...it looks like the printer sent back `ok` (acknowledgement) but not cleanly on a new line. I'm not sure, but I think this is more likely to happen some short while after the printer has apparently finished "booting", and in the early stages of OctoPrint starting to query it.

I will have to look into this a bit more, and compare across failures to see if it's always the same thing, and whether it is always the same conditions.

## Trying out Digispark DigiCDC (USB serial) with Linux

Side-stepping for a sec: Can I make DigiCDC work on a Digispark, with a Linux VM? And what about with macOS?

Doco already says it needs a driver for Windows, so I'll forget that for now.

Here's [`DigiCDC.h`](https://github.com/digistump/DigistumpArduino/blob/master/digistump-avr/libraries/DigisparkCDC/DigiCDC.h) which we can examine for features. The main parts appear to be these methods of `SerialUSB`:
*   `begin()` -- Open comms.
*   `refresh()` -- Keep-alive.
*   `task()` -- No idea??
*   `delay()` -- Refresh-friendly delay.
*   `available()` -- Is there data that we can read?
*   `peek()` -- Look at data but don't unbuffer it.
*   `read()` -- Read (i.e. unbuffer) data.
*   `flush()` -- Not sure. Push out any buffered data, then return when no longer busy?
*   `write()` -- Write a byte.
*   Note also that it extends `Stream` which appears to include `Print::write` functionality.

Some info [here](https://groups.google.com/d/msg/androidscript/qCtNGjLRaS8/XXlwztNZBwAJ) about Digispark USB device VIDs (Vendor IDs) and PIDs (Product IDs), and that post leads to other discussions that might be useful.

