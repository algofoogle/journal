# 14 Oct 2023

| Previous journal: | Next journal: |
|-|-|
| [**0158**-2023-10-13.md](./0158-2023-10-13.md) | *Next journal TBA* |

# Continuing tt05vsr (tt05-vga-spi-rom) tests

## Different on/off options to consider for final design

*   Collapse state to only consider first 32 bits, and hence repeat the MOSI pattern. Good for testing jitter.
*   Masking out certain bits.
*   Registers to adjust state stuff, inc. offset, when to turn /CS on/off...? Would work best with test004 model.


## `test004-combo`

Change FSM to combo logic, i.e. don't use registers to control SPI outputs, but rather direct combo logic based on hpos (or rather, `state`, derived from `hpos`).

4 versions:
*   [Detailed with 'x'](https://github.com/algofoogle/tt05-vga-spi-rom/actions/runs/6515265299):
    *   41.99% util; 972 total cells.
    *   ![test004 detailed with 'x'](i/0159-test004-x.png)
*   [Simple with '0'](https://github.com/algofoogle/tt05-vga-spi-rom/actions/runs/6515336218):
    *   41.58% util; 972 total cells.
    *   ![test004 simple with '0'](i/0159-test004-0.png)
    *   This seems to output the same MOSI data as the one above, so probably no different -- just slightly changed layout?
*   [Just 32 MOSI states](https://github.com/algofoogle/tt05-vga-spi-rom/actions/runs/6515621381):
    *   41.24% util; 965 total cells.
    *   ![test004 - Just 32 MOSI states](i/0159-test004-32states.png)
    *   This one only worries about the MOSI states that matter (first 32), and doesn't care about the rest. In fact, it just repeats those same 32, but this means it litters the display. Interestingly, though, it's unstable too, i.e. some lines have bits that jitter:
        ![32 states exposing jitter](./i/0159-test004-jitter.gif)
    *   Observations on jitter:
        *   Could be due to cross-talk
        *   Could be fixed with decoupling, shorter wires, etc? Less effect seen if MISO weakly pulled high (on HOLD# pin) vs. VCC or VSS.
        *   Almost NO effect if MISO pulled to SCLK or MOSI??
*   [Reverted to 'simple with 0' and tidied up](https://github.com/algofoogle/tt05-vga-spi-rom/actions/runs/6515807137):
    *   41.57% util; 979 (!) total cells.
    *   ![Tidied test004 with simple 0](i/0159-test004-simple-tidied.png)
    *   Logic change was to make stored_mode region start at hpos==416 instead of 408, so the byte boundaries are the same.

Final output from test004-combo branch:

![Final output from test004-combo branch](./i/0159-test004-final.jpg)


## `test005-ram`

Replace data_buffer with actual RAM. Does it make data retrieval easier without needing negedge-to-display? Use bit index in vector, or actual addressed memory array?

Maybe try a version of this based on test002A, and another on test004.

![]()


## `test006-statereg`

Add extra 'state' counter register that starts at hmax... but will this suffer the same vpos offset issue? Well maybe but we can probably make that not matter with a little trickery.

![]()


# spiflash issues

Despite my design working on an FPGA with a real SPI flash ROM chip, I was getting unexpected cocotb test results when using `spiflash.v`:

![spiflash just echoing out what it gets in](./i/0158-spiflash-echo.png)

My expectation, from datasheets, was that MISO should be HiZ until after the READ (03h) command and address are both sent. Also, we shouldn't be seeing MISO repeat MOSI (in this case with a 1-byte delay). From looking deeper into spiflash's state in the VCD, I found that `powered_up` was always 0, and this doesn't seem right. With `spiflash` the only way to switch it on is by sending the wakeup command (`ABh`, aka `RES`, aka 'Release from Deep Power Down / Device Id'), because the code specifies `reg powered_up = 0` as the initial state. Datasheets (and using a real device) suggest this is wrong. Anyway, maybe that's intentional to make sending `ABh` first a normal safety protocol. We can do that; probably best to do so during the first line, plenty of cycles before that first stored-mode read starts.

