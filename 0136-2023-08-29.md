# 29 Aug 2023

| Previous journal: | Next journal: |
|-|-|
| [**0135**-2023-08-28.md](./0135-2023-08-28.md) | *Next journal TBA* |

# wall_tracer changes

*   Consider better names for FSM states. They're confusing right now.
*   For now, embed height_scaler reciprocal.
    This changes o_vdist to o_size.
*   stepDist needs to be registered now. They are directly calculated by rcp, and rely on rayDir as inputs. rayDir is sum of facing and minified rayAddend. rayAddend is registered before PREP, then updated during DONE.
*   WARNING: trackDist comes from trackInit, which depends on stepDist!
*   PREP state could start to ready the rcp for rayDirX.
*   Need a state to calculate and register o_size.
*   Really naive states:
    *   SETUP_RDX_RCP: Setup rayDirX reciprocal.
        *   `rcp_in <= rayDirX`
        *   `rcp_abs <= 1`
    *   WAIT_SDX: (OPTIONAL) Wait state.
        *   Do nothing
    *   LOAD_SDX: Load stepDistX from rayDirX reciprocal.
        *   `stepDistX <= rcp_out` -- could be combined with next step.
    *   SETUP_RDY_RCP: Setup rayDirY rcp.
        *   `rcp_in <= rayDirY`
    *   WAIT_SDX: (OPTIONAL) Wait state.
        *   Do nothing
    *   LOAD_SDY: Load stepDistY from rayDirY rcp.
        *   `stepDistY <= rcp_out` -- could be combined with next step.
    *   TRACE_PREP:
        *   Set initial mapXY.
        *   Set trackDist, from trackInit.
    *   TRACE_STEP:
        *   As-is.
    *   TRACE_TEST: -- later might get complex: map setup/read states esp. for SPI flash.
        *   As-is.
    *   TRACE_DONE:
        *   Modify this to use rcp to get size from vdist.
    *   More states required before hitting LINE_READY (which is when we present output).
*   Max. expected clocks needed for tracing:
    *   Each line:
        *   Reset
        *   3 for RDX rcp
        *   3 for RDY rcp
        *   TRACE_PREP
        *   *(Corner-to-corner of 64x64 map is about 90 cells. This could mean 90 X tests, and 90 Y tests, though realistically shouldn't be more than 64 of each. Let's work with 90, though...)*
        *   180x STEP
        *   180x TEST
        *   TRACE_DONE
        *   3 for vdist rcp
        *   TOTAL: 372 max.
    *   But I THINK for all reasonable cases it should be more like 12+(128*2)=268
    *   This means that our 800-wide line could be made up of:
        *   270 tracing clocks.
        *   256 map overlay clocks (to avoid ROM contention).
        *   274 spare clocks -- divide by 5 means we could receive up to 54 SPI bits, but more likely 40 given MCU response time. Hence, we could load new 80-bit vectors within 2 lines (so long as they were double-buffered on input), or 144-bit vectors within 4 lines.
    *   NOTE: Timing gets much worse if we need to support reading from SPI ROM. In that case, maybe it would be better to have:
        *   An initial state just for clocking out a 12-bit address (made up of )
*   IS there a way to combine STEP and TEST? I feel like there should be:
    *   Maybe there's even a way to avoid `trackDistY-stepDistY` by holding a previous value.

Wacky idea: tracer just sends an 'increment' or 'decrement' signal to map X and Y outputs, and an external device keeps track of where that's up to and what it maps to. This would allow potentially non-square maps.
