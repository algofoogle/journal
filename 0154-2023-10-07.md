# 7 Oct 2023

| Previous journal: | Next journal: |
|-|-|
| [**0153**-2023-10-06.md](./0153-2023-10-06.md) | *Next journal TBA* |

# More SPI stuff

*   I was reading that it *seems* SPI slave devices have an internal clock running (perhaps a ring osc) at a multiple (maybe 4x or 6x?) faster than their expected maximum data rate, to allow other logic to run rather than just being limited to SCLK.
*   Today I want to try making my FPGA-based SPI master control the SPI flash ROM slave at full speed, i.e. make it clock SCLK at the same speed as my design's CLK, but inverted.
*   I need to mentally work out possible glitches that could occur with gating SCLK (or even NOT gating it) when it is simply driven by !CLK.
*   If there is no other solution, I might need to have a forced delay ([`(* keep *)`](https://docs.xilinx.com/r/en-US/ug901-vivado-synthesis/KEEP-Example-Verilog)? Also [`synthesis keep`](https://www.intel.com/content/www/us/en/programmable/quartushelp/17.0/hdl/vlog/vlog_file_dir_keep.htm) like [this](https://www.fpgadeveloper.com/2011/06/how-to-keep-a-signal-name-after-mapping.html/) too, and check [this](https://www.reddit.com/r/yosys/comments/e456jg/any_way_to_do_an_equivalent_of_synthesis_syn_keep/)), use a faster system clock (e.g. 50MHz, to attain 25MHz SCLK), or use an internal ring osc to make a high-speed master FSM.
*   Can we make use of both `posedge` and `negedge`?
*   Could we peg SCLK safely for one whole extra clock either side of /CS transitions, to ensure that glitches don't happen UPON /CS transition, but rather before or after?
*   See if we can deliberately glitch SCLK relative to /CS, and see what happens.
*   cocotb and spiflash sim: both in iverilog (test benches) and verilator (visual sim).
*   **NOTE:** The leading /CS assert and coincident/subsequent SCLK edge might end up all being fine, but just be aware that when /CS is released, we don't want an erroneous extra SCLK edge to be sensed that could put a 'Continuous Mode' out of order. I think if SCLK goes high, gets *pegged* high, and then /CS is released, we'll be OK... just so long as a SCLK falling edge is NOT detected.

# Findings

DON'T FORGET: When reacting to something on counter==X, the reaction will occur at the same time as counter==X+1.

I [modified](https://github.com/algofoogle/sandpit/blob/b51016a22886b21da146bf592d370728b625dd1b/fpga/vga_spi_rom/src/rtl/vga_spi_rom.v) the design to:
*   Drive SCLK constantly, from the inverse of the system CLK. This allows us to latch MOSI data on the rising edge of CLK, and then know that it will be stable for the SPI slave on SCLK's rising edge (i.e. CLK's FALLING edge).
*   Start each line address at the next 64 bytes, so we can see at least 64 bytes per line.
*   Make each 'line' 2px tall, with even lines being black to make it easier to see individual bytes.

Here's how it looks, and it seems to prove that SCLK running at 25MHz in this way is working OK:

![1x2 bits](./i/0154-1x2.jpg)

# Next steps

*   Get rid of pointless states.
*   Try *storing* these values in BRAM during HBLANK, reading/storing at full speed, then display them during visible area. In fact, try doing both methods (on alternating lines) to check for possible errors.
*   Try Dual or even Quad SPI.
*   Design a better FSM to simplify how we setup, write CMD, write ADDR, and then read data.
*   Check with the Discord crew whether this design is flawed, esp. if it gets made into standard cells.
*   How hard would it be to implement this in discrete logic?
*   Write image/test-pattern data to the ROM.

# TT05 ideas

*   VGA 'probe'
*   VGA 'sync' follower
*   SPI test device, even just to display SPI ROM contents on screen
*   VGA different frequencies
*   Ring osc
